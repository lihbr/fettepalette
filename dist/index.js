export const hsv2hsl=(s,r,o,n=o-o*r/2,b=Math.min(n,1-n))=>[s,b?(o-n)/b:0,n],random=(s,r)=>(r||(r=s,s=0),Math.random()*(r-s)+s),pointOnCurve=(s,r,o,n,b=[0,0],p=[1,1])=>{const x=Math.PI/2,m=x/o;let e,h;if(s==="lam\xE9"){let a=r/o*x;const M=2/(2+20*n),t=Math.cos(a),u=Math.sin(a);e=Math.sign(t)*Math.abs(t)**M,h=Math.sign(u)*Math.abs(u)**M}else s==="arc"?(h=Math.cos(-Math.PI/2+r*m+n),e=Math.sin(Math.PI/2+r*m-n)):s==="pow"?(e=Math.pow(1-r/o,1-n),h=Math.pow(r/o,1-n)):s==="powY"?(e=Math.pow(1-r/o,n),h=Math.pow(r/o,1-n)):s==="powX"&&(e=Math.pow(r/o,n),h=Math.pow(r/o,1-n));return e=b[0]+Math.min(Math.max(e,0),1)*(p[0]-b[0]),h=b[1]+Math.min(Math.max(h,0),1)*(p[1]-b[1]),[e,h]};export default function Y(s,r=0,o=.3,n=.1,b=.1,p=0,x=.1,m="arc",e=.03,h=.03,a=[0,0],M=[1,1]){const t=[],u=[],y=[];for(let l=1;l<s+1;l++){const[C,g]=pointOnCurve(m,l,s+1,p,a,M),w=(360+(-180*o+(r+l*(360/(s+1))*o)))%360,d=hsv2hsl(w,C,g);t.push([d[0],d[1],d[2]]);const[I,P]=pointOnCurve(m,l,s+1,p+e,a,M),f=hsv2hsl(w,I,P);u.push([(w+360*x)%360,f[1]-n,f[2]+n]);const[R,X]=pointOnCurve(m,l,s+1,p-h,a,M),k=hsv2hsl(w,R,X);y.push([(360+(w-360*x))%360,k[1]-b,k[2]-b])}return{light:u,dark:y,base:t,all:[...u,...t,...y]}}
